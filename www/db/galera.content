<h3><a href="#db"  > Database</a> - Mariadb Galera Cluster</h3>
<draft/>
Your application is connected to a single backend mysql/mariadb database node (Master/Slave mode) and your thinking of scaling it by upgrading to galera based multi-master mariadb database cluster.
Oh Yes! we are. This article will walk you through the limitations and behavior that you need to deal with when making a move and will help you decide/design if that is a good choice for you.</p>

<h4>AUTOINCREMENTS</h4>
Expect to have gaps in autoincremented values. The gap is equal to the number of nodes in the galera cluster.
</p>
<h4>LOCKS</h4>
<i>In Galera, table row locks are not visible across the nodes. It follows an optimistic approach and transactions running on different nodes can acquire lock on the same table rows.</i></p>

Transactions compete for the same table row locks.
<ul>
<li>A [S]hared Read lock and e[X]clusive Write lock</li>
<li>An e[X]clusive Write lock with other e[X]clusive Write lock</li>
</ul>
However, they  will not have much of a trouble on a single node. One gets the lock and rest can wait, and if the waiting was long enough you would see below error.
<pre>
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</pre>
All goes well, if each finishes quick enough.

</p>
The scene completely changes when you move to galera. Where you have multiple master nodes.
If connections go to two different node then what would usually work well in a single node setup will give you sudden surprises and headaches.</p>
The infamous error
<pre>
ERROR 1213 (40001): WSREP detected deadlock/conflict and aborted the transaction. Try restarting the transaction
</pre>

<i>Welcome to the brand new world of deadlocks!</i></p> 

<h4>Surprise #1</h4>
Tables connected by a foriegn key.
<pre>
<b>Transaction #1 [Node #1]</b>
update table A set ... where pk_a = val;
[X Lock]

<b>Transaction #2 [Node #2]</b>
--An INSERT--(has FK reference to table A (pk_a) ) 
insert into table B ( ..., fk_a ) values ( ..., pk_a_val );
[S Lock]

--OR

--An UPDATE--(has FK reference to table A(pk_a) )
update B set fk_a = pk_a_val ...; 
[S Lock]
</pre>

<h4>Surprise #2</h4>
Working on a same table.
<pre>
<b>Transaction #1 [Node #1]</b>
update table A
[X Lock]

<b>Transaction #2 [Node #2]</b>
update table A
[X Lock]
</pre>
You would say, wouldn't an optimistic locking solution in will take care of Surprise #2. But beware, there is still a possiblility you could still end up in conflict i.e., when both transactions have made the update before one of them commits the changes (test it for yourself).

Handle concurrent data access in your application using some sort of pessimistic global locking. You cannot rely on the database table locks.</p>

<h4>LARGE TRANSACTIONS</h4>
Other problem that you got to deal with are large transactions i.e. handling too much of data. Such transactions will put all other changes in the queue and can slow down the replication depending on your network conditions. It will affect the overall QPS.</p>
Fail fast and retry.</p>

<h4>CROSS SITE REPLICATION</h4>
You can use gmcast.segment option to group nodes present in the same network. This will optimize the galera protocol traffic. And in some cases IST and SST selection within the segment.
