<h3><a href="#linux" onclick="_().loadContent(this,'linux','ContentBody');" >C++</a> - Sojourn, a light weight key value store</h3></p>
<r>Work in progress!!!</r>
A simple inmemory key value store.
<pre>
#include &lt;iostream>
#include &lt;sys/types.h>
#include &lt;unistd.h>
#include &lt;sys/socket.h>
#include &lt;netdb.h>
#include &lt;arpa/inet.h>
#include &lt;string.h>
#include &lt;string>

#include &lt;thread>
#include &lt;shared_mutex>
#include &lt;map>
#include &lt;vector>

const int MAX_CONNECTIONS = 2;

class ThreadNg {
    bool busy;
    std::thread thread_handle;
    public:

    ThreadNg() {
        busy = false;
        printf("Worker created...\n");
    }

    bool Status() {
        return busy;
    }

    template&lt;class F, class... Args>
        void thread_wrapper(F&& user_function, Args&&... args) {
            printf("function started...\n");
            user_function(std::ref(args)...);
            printf("function ended...\n");
            busy = false;
        }

    template&lt;class F, class... Args>
        void Run(F&& f, Args&&... args) {
            busy = true;
            thread_handle = std::thread( &ThreadNg::thread_wrapper&lt;typename std::decay&lt;F>::type,
                    typename std::decay&lt;Args>::type...>,
                    this,
                    std::forward&lt;F>(f),
                    std::forward&lt;Args>(args)... );
        }

    void Join() {
        if ( thread_handle.joinable() )
            thread_handle.join();
        else
            printf("Nothing to wait for...\n");
    }

    ~ThreadNg() {
        printf("In the destructor...\n");
        if ( thread_handle.joinable() )
            thread_handle.join();
        else
            printf("Nothing to wait for...\n");
        printf("Worker destroyed...\n");
    }
};

std::shared_mutex KeyValueStoreRWLock;

struct cmp_str {
    bool operator()(char const *a, char const *b) const {
        return strcmp(a, b) &lt; 0;
    }
};

static std::map&lt;const char *, const char *, cmp_str> keyValueStore;

const char *get_from_keyValueStore(const char *key) {
    std::shared_lock&lt;std::shared_mutex> shared_read(KeyValueStoreRWLock);
    return keyValueStore.find(key)->second;
}

bool erase_from_keyValueStore(const char *key) {
    std::lock_guard&lt;std::shared_mutex> exclusive_write(KeyValueStoreRWLock);
    if (keyValueStore.find(key)->second != NULL) {
        const char* k = keyValueStore.find(key)->first;
        const char* v = keyValueStore.find(key)->second;
        printf("Memory address: %p %p\n", k, v);
        keyValueStore.erase(key);
        fflush(stdout);
        delete k;
        delete v;
        return true;
    }
    return false;
}

bool add_to_keyValueStore(const char *key, const char *val) {
    std::lock_guard&lt;std::shared_mutex> exclusive_write(KeyValueStoreRWLock);
    if (keyValueStore.find(key)->second == NULL) {
        char *insertKey, *insertVal;
        insertKey = new char[strlen(key + 1)];
        insertVal = new char[strlen(val + 1)];
        strcpy(insertKey, key);
        strcpy(insertVal, val);
        printf("Memory address: %p %p\n", insertKey, insertVal);
        fflush(stdout);
        keyValueStore.insert({insertKey, insertVal});
        return true;
    }
    return false;
}

void handle_connection(int &clientSocket) {
    char buf[4096];
    char command[256], key[256], val[256];
    int pk = 0, k = 0;
    int iteration = 0;

    bool repl = true;

    while (repl) {
        memset(buf, 0, 4096);
        memset(command, 0, 256);
        memset(key, 0x00, 256);
        memset(val, 0x00, 256);

        try {
            int bytesRecv = recv(clientSocket, buf, 4096, 0);
            if (bytesRecv == -1) {
                std::cerr &lt;&lt; "Connection issue." &lt;&lt; std::endl;
                break;
            }
            if (bytesRecv == 0) {
                std::cout &lt;&lt; "The client disconnected" &lt;&lt; std::endl;
                break;
            }

            pk = 0;
            k = 0;
            iteration = 0;

            for (int i = 0; i &lt; bytesRecv && iteration &lt; 3; i++) {
                if (k > 255) {
                    printf("Key size exceeded...");
                    break;
                }
                if (buf[i] == ' ' || buf[i] == '\r') {
                    switch (iteration) {
                        case 0:
                            strncpy(command, (const char *)(buf + pk), k);
                            break;
                        case 1:
                            strncpy(key, (const char *)(buf + pk), k);
                            break;
                        case 2:
                            strncpy(val, (const char *)(buf + pk), k);
                            break;
                    }
                    iteration++;
                    pk += k + 1;
                    k = 0;
                } else {
                    k++;
                }
            }

            if (strcmp(command, "exit\0") == 0 || strcmp(command, "quit\0") == 0) {
                repl = false;
                break;
            }

            if (strcmp(command, "DEL\0") == 0 || strcmp(command, "del\0") == 0) {
                if (erase_from_keyValueStore(key)) {
                    char message[9] = "Del Ok";
                    send(clientSocket, strcat(message, "\r\n"), strlen(message) + 3, 0);
                }
            }

            if (strcmp(command, "GET\0") == 0 || strcmp(command, "get\0") == 0) {
                const char *value = get_from_keyValueStore(key);
                if (value != NULL) {
                    char message[264];
                    strcpy(message, "Value=");
                    strcat(message, value);
                    send(clientSocket, strcat(message, "\r\n"), strlen(message) + 3, 0);
                    printf("Bytes sent : %zd message = %s\n", strlen(message), message);
                }
            }

            if (strcmp(command, "SET\0") == 0 || strcmp(command, "set\0") == 0) {
                if (add_to_keyValueStore(key, val)) {
                    char message[9] = "Set Ok";
                    send(clientSocket, strcat(message, "\r\n"), strlen(message) + 3, 0);
                    printf("Bytes added : %zd\n", strlen(val));
                }
            }

        } catch (std::exception &e) {
            std::cout &lt;&lt; "exception : " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }

    close(clientSocket);

    delete &clientSocket;

    std::cout &lt;&lt; "---Exited  thread" &lt;&lt; std::endl;
}

int main() {

    ThreadNg ThreadNgCollection[MAX_CONNECTIONS];
    int activeThreads = 0;

    int listening = socket(AF_INET, SOCK_STREAM, 0);
    if (listening == -1) {
        std::cerr &lt;&lt; "Can't create a socket" &lt;&lt; std::endl;
        return -1;
    }

    sockaddr_in hint;
    hint.sin_family = AF_INET;
    hint.sin_port = htons(54000);

    inet_pton(AF_INET, "0.0.0.0", &hint.sin_addr);

    if (bind(listening, (const sockaddr *)&hint, sizeof(hint)) == -1) {
        std::cerr &lt;&lt; "Can't bind to IP/Port" &lt;&lt; std::endl;
        return -2;
    }

    if (listen(listening, SOMAXCONN) == -1) {
        std::cerr &lt;&lt; "Can't listen!" &lt;&lt; std::endl;
    }

    sockaddr_in client;
    socklen_t clientSize = sizeof(client);
    char host[NI_MAXHOST];
    char svc[NI_MAXSERV];

    bool forever = true;
    size_t connections = 0;

    int thread_num = 0;
    while (forever) {
        int *clientSocket = new int;
        *clientSocket = accept(listening, (sockaddr *)&client, &clientSize);

        if (*clientSocket == -1) {
            std::cerr &lt;&lt; "Problem with client connecting!" &lt;&lt; std::endl;
        } else {
            printf("CONNECTED at socket=%p.\n", clientSocket);
            connections++;
        }

        memset(host, 0, NI_MAXHOST);
        memset(svc, 0, NI_MAXSERV);

        int result = getnameinfo((sockaddr *)&client, clientSize, host, NI_MAXHOST,
                svc, NI_MAXSERV, 0);

        if (result)
            std::cout &lt;&lt; host &lt;&lt; " -> connected on " &lt;&lt; svc &lt;&lt; std::endl;
        else {
            inet_ntop(AF_INET, &client.sin_addr, host, NI_MAXHOST);
            std::cout &lt;&lt; host &lt;&lt; " : connected on " &lt;&lt; ntohs(client.sin_port)
                &lt;&lt; std::endl;
        }

        int handled = false;
        int attempts = 0;

        while ( attempts&lt;2*MAX_CONNECTIONS ) {
            if ( !ThreadNgCollection[thread_num].Status() ) {
                ThreadNgCollection[thread_num].Join();
                printf("Assigning job to thread : %d\n", thread_num);
                ThreadNgCollection[thread_num].Run(handle_connection, std::ref(*clientSocket));
                handled = true;
                break;
            }
            thread_num=(thread_num+1)%MAX_CONNECTIONS;
            attempts++;
        }

        if (!handled) {
            printf("Too many client connections...\n");
            close(*clientSocket);
            delete clientSocket;
        }

        activeThreads=0;
        for( auto& i : ThreadNgCollection ) {
            if (i.Status())
                activeThreads++;
        }
        std::cout &lt;&lt; "Total  connections : " &lt;&lt; connections &lt;&lt; std::endl;
        std::cout &lt;&lt; "Active connections : " &lt;&lt; activeThreads &lt;&lt; std::endl;
    }

    close(listening);
    return 0;
}
</pre>
Build
<pre>
g++ -O3 -std=c++17 -pthread sojourn.cpp -o sojourn
</pre>
Thanks</br>
