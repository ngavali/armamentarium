<h3><a href="#linux" onclick="_().loadContent(this,'linux','ContentBody');" >Containers</a> - Let's build one</h3></p>
<r>Working on it. Coming soon!!!</r></p>
In case you want to have a look at namespaces basic click <a href="#linux/container_intro" onclick="_().loadContent(this,'linux/container_intro','ContentBody');">introduction</a>.</p>
Example uses hindu mythological names</br>
Brahma the creator of all Lokas (different worlds)</br>
<*>Loka is an analogy for the container.</br>
<*>Brahma is the container spawner</p>
Have a linux filesystem structure created under /containerfs directory (accessible via user executing this binary). Which will have all the essential utilities such as bash and other per your need.

<h3>Go</h3>
<pre>
package main

import (
        "fmt"
        "os"
        "os/exec"
        "syscall"
)

func main() {
        switch os.Args[1] {
        case "run":
                run()
        case "loka":
                loka()
        default:
                fmt.Println("Usage: ./brahma run command")
        }
}

func run() {
        fmt.Printf("Creating Loka for %v\n", os.Args[2:])
        cmd := exec.Command("/proc/self/exe", append([]string{"loka"}, os.Args[2:]...)...)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &syscall.SysProcAttr{
                Cloneflags: syscall.CLONE_NEWNS |
                        syscall.CLONE_NEWUTS |
                        syscall.CLONE_NEWIPC |
                        syscall.CLONE_NEWPID |
                        syscall.CLONE_NEWNET |
                        syscall.CLONE_NEWUSER,
                //Map UID
                UidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getuid(), //UID of current program to be mapped with
                                ContainerID: 0,           //UID in container
                                Size:        1,
                        },
                },
                //Map GID
                GidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getgid(), //GID of current program to be mapped with
                                ContainerID: 0,           //GID in container
                                Size:        1,
                        },
                },
        }
        _err := cmd.Start()
        if _err != nil {
                fmt.Println("Error while creating Loka ->", _err)
        } else {
                fmt.Println("Loka created successfully!!!")
        }
        if _err := cmd.Wait(); _err != nil {
                fmt.Println("Error while in Loka ->", _err)
        }
        fmt.Println("Loka distroyed!!!")
}

func loka() {
        fmt.Printf("Preparing %v in new Loka\n", os.Args[2:])
        syscall.Sethostname([]byte("my-loka"))
        syscall.Chroot("/containerfs")               //New root for the Loka container
        syscall.Chdir("/")                           //Change directory
        syscall.Mount("proc", "proc", "proc", 0, "") //Mount new proc
        //Replace the current process. Leaving no trace of the parent /proc/self/exe
        _err := syscall.Exec(os.Args[2], os.Args[3:], nil)
        if _err != nil {
                fmt.Println("Loka error ->", _err)
        }
        fmt.Println("I am dying!!!")
}
</pre>
<h3>Rust</h3>
Working on moving to using libc!!!
<pre>
extern crate unshare;
use std::env;
use std::ffi::CString;
use std::io::Error;
use unshare::{Command, Namespace};
extern crate clap;
extern crate libc;
use clap::{App, Arg};

fn ns(command: String) {
    println!("Spawning /bin/bash");
    //const NONE: Option<&'static [u8]> = None; //VOID...
    unsafe {
        let res = libc::chroot(CString::new("/containerfs/").unwrap().as_ptr());
        println!("CHROOT -> {}", res);
        println!("ERROR WHILE RUNNING -> {:?}", Error::last_os_error());
    }
    unsafe {
        let res = libc::chdir(CString::new("/").unwrap().as_ptr());
        println!("CHDIR -> {}", res);
        println!("ERROR WHILE RUNNING -> {:?}", Error::last_os_error());
    }
    unsafe {
        let res = libc::mount(
            CString::new("").unwrap().as_ptr(),
            CString::new("/proc").unwrap().as_ptr(),
            CString::new("proc").unwrap().as_ptr(),
            0u64,
            CString::new("").unwrap().as_ptr() as *const libc::c_void,
        );
        println!("MOUNT -> {}", res);
        println!("ERROR WHILE RUNNING -> {:?}", Error::last_os_error());
    }

    let exec_cstr: CString = CString::new("/bin/bash".as_bytes()).unwrap();
    let prog: *const libc::c_char = exec_cstr.as_ptr();

    let mut args: Vec<CString> = Vec::with_capacity(3);
    args.push(CString::new(b"/bin/bash".as_ref()).unwrap());

    let mut args_raw: Vec<*const libc::c_char> = args.iter().map(|arg| arg.as_ptr()).collect();
    args_raw.push(std::ptr::null());

    let argsv: *const *const libc::c_char = args_raw.as_ptr();

    unsafe {
        libc::execv(prog, argsv);
        println!("ERROR WHILE RUNNING -> {:?}", Error::last_os_error());
    }
}

fn parse_args() -> (bool, bool, String) {
    let matches = App::new("brahma")
        .version("1.0")
        .author("Nilesh Gavali")
        .arg(
            Arg::with_name("run")
                .short("r")
                .long("run")
                .takes_value(false),
        )
        .arg(
            Arg::with_name("namespace")
                .short("n")
                .long("namespace")
                .takes_value(false),
        )
        .arg(
            Arg::with_name("entry point")
                .short("e")
                .long("entry")
                .takes_value(true)
                .required(true),
        )
        .get_matches();
    let is_run_command = matches.is_present("run");
    let is_ns_command = matches.is_present("namespace");
    let entry_point = matches.value_of("entry point").unwrap();
    (is_run_command, is_ns_command, entry_point.to_string())
}

fn main() {
    match parse_args() {
        (_, true, command) => ns(command),
        (true, _, command) => {
            let mut namespaces = Vec::<Namespace>::new();
            namespaces.push(Namespace::Pid);
            namespaces.push(Namespace::Mount);
            namespaces.push(Namespace::Uts);
            namespaces.push(Namespace::Net);
            namespaces.push(Namespace::User);
            namespaces.push(Namespace::Ipc);
            let uid_map = vec![unshare::UidMap {
                inside_uid: 0,
                outside_uid: 1000,
                count: 1,
            }];
            let gid_map = vec![unshare::GidMap {
                inside_gid: 0,
                outside_gid: 1000,
                count: 1,
            }];
            let mut cmd = Command::new("/proc/self/exe");
            cmd.args(&["--namespace", "--entry", command.as_ref()]);
            cmd.set_id_maps(uid_map, gid_map);
            cmd.unshare(&namespaces);
            match cmd.spawn() {
                Ok(mut res) => {
                    println!("spawned self. {:#?}", res);
                    match res.wait() {
                        Ok(res) => println!("wait successful on self spawn. {}", res),
                        Err(_err) => println!("wait failed on self spawn. {}", _err),
                    }
                }
                Err(_err) => println!("self spawn to ns error. Error -> {}", _err),
            }
        }
        (_, _, _) => println!("Don't know what to do!!! Please check usage."),
    }
}
</pre>
