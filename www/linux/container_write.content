<h3><a href="#linux" onclick="_().loadContent(this,'linux','ContentBody');" >Containers</a> - Let's build one</h3></p>
<r>Working on it. Coming soon!!!</r></p>
In case you want to have a look at basics of Namespaces, click <a href="#linux/container_intro" onclick="_().loadContent(this,'linux/container_intro','ContentBody');">introduction</a>.</p>
<center>
<image src="/images/container_flow.svg" width="400px">
Fig(a). execution flow.</p>
</center>
<!--
Example uses hindu mythological names</br>
Brahma the creator of all Lokas (different worlds)</br>
<*>Loka is an analogy for the container.</br>
<*>Brahma is the container spawner</p>-->
Have a linux filesystem structure created under /containerfs directory (accessible via user executing this binary). Which will have all the essential utilities such as bash and other per your need. Copy them from the local system into this directory.</p>
<pre>
/containerfs/
├── bin		#some utilities
│   ├── bash	#required
│   ├── hostname
│   ├── ls
│   ├── ping
│   ├── ps
├── etc
├── file
├── lib
│   └── x86_64-linux-gnu
│       ├── libacl.so.1
│       ├── libattr.so.1
│       ├── libblkid.so.1
│       ├── libcap.so.2
│       ├── libc.so.6
│       ├── libdl.so.2
│       ├── libmount.so.1
│       ├── libnsl.so.1
│       ├── libpcre.so.3
│       ├── libprocps.so.3
│       ├── libselinux.so.1
│       ├── libtinfo.so.5
│       └── libuuid.so.1
├── lib64
│   └── ld-linux-x86-64.so.2
├── mp
├── proc
├── sbin
│   ├── ifconfig
│   └── ip
└── usr
    └── bin
        └── id
</pre>
Short version
<h3>Go</h3>
<pre>
package main

import (
        "fmt"
        "os"
        "os/exec"
        "syscall"
)

func main() {
        switch os.Args[1] {
        case "run":
                run()
        case "loka":
                loka()
        default:
                fmt.Println("Usage: ./brahma run command")
        }
}

func run() {
        fmt.Printf("Creating Loka for %v\n", os.Args[2:])
        cmd := exec.Command("/proc/self/exe", append([]string{"loka"}, os.Args[2:]...)...)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &syscall.SysProcAttr{
                Cloneflags: syscall.CLONE_NEWNS |
                        syscall.CLONE_NEWUTS |
                        syscall.CLONE_NEWIPC |
                        syscall.CLONE_NEWPID |
                        syscall.CLONE_NEWNET |
                        syscall.CLONE_NEWUSER,
                //Map UID
                UidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getuid(), //UID of current program to be mapped with
                                ContainerID: 0,           //UID in container
                                Size:        1,
                        },
                },
                //Map GID
                GidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getgid(), //GID of current program to be mapped with
                                ContainerID: 0,           //GID in container
                                Size:        1,
                        },
                },
        }
        _err := cmd.Start()
        if _err != nil {
                fmt.Println("Error while creating Loka ->", _err)
        } else {
                fmt.Println("Loka created successfully!!!")
        }
        if _err := cmd.Wait(); _err != nil {
                fmt.Println("Error while in Loka ->", _err)
        }
        fmt.Println("Loka distroyed!!!")
}

func loka() {
        fmt.Printf("Preparing %v in new Loka\n", os.Args[2:])
        syscall.Sethostname([]byte("my-loka"))
        syscall.Chroot("/containerfs")               //New root for the Loka container
        syscall.Chdir("/")                           //Change directory
        syscall.Mount("proc", "proc", "proc", 0, "") //Mount new proc
        //Replace the current process. Leaving no trace of the parent /proc/self/exe
        _err := syscall.Exec(os.Args[2], os.Args[3:], nil)
        if _err != nil {
                fmt.Println("Loka error ->", _err)
        }
        fmt.Println("I am dying!!!")
}
</pre>
Long version
<h3>Rust</h3>
I am still working on it!!!</br>
Here you will see exactly what is happening under the hood.
<pre>
extern crate clap;
extern crate libc;
use clap::{App, Arg};
use libc::{
    CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, CLONE_NEWUSER, CLONE_NEWUTS, SIGCHLD,
};
use std::ffi::CString;
use std::fs::OpenOptions;
use std::io::prelude::*;
use std::io::Error;

#[derive(Debug, Clone)]
struct Cmd {
    path: CString,
    args: Vec<CString>,
}

impl Cmd {
    fn new(path: CString, args: Vec<CString>) -> Cmd {
        Cmd { path, args }
    }
}

#[derive(Debug, Clone)]
struct UserMap {
    uid: u16,
    gid: u16,
}

impl UserMap {
    fn new(uid: u16, gid: u16) -> UserMap {
        UserMap { uid, gid }
    }
}

#[derive(Debug, Clone)]
struct NsConfig {
    command: Cmd,
    chroot_path: CString,
    user_map: UserMap,
    hostname: CString,
}

impl NsConfig {
    fn new(command: Cmd, chroot_path: CString, user_map: UserMap, hostname: CString) -> NsConfig {
        NsConfig {
            command,
            chroot_path,
            user_map,
            hostname,
        }
    }

    fn entry_point(&self) -> Cmd {
        self.command.clone()
    }

    fn user_map(&self) -> UserMap {
        self.user_map.clone()
    }

    fn chroot_path(&self) -> CString {
        self.chroot_path.clone()
    }
}

fn parse_args() -> NsConfig {
    let matches = App::new("brahma")
        .version("1.0")
        .author("Nilesh Gavali")
        .arg(
            Arg::with_name("run")
                .short("r")
                .long("run")
                .takes_value(false)
                .required(false),
        )
        .arg(
            Arg::with_name("namespace")
                .short("n")
                .long("namespace")
                .takes_value(false)
                .required(false),
        )
        .arg(
            Arg::with_name("entry point")
                .short("e")
                .long("entry")
                .takes_value(true)
                .required(true),
        )
        .arg(
            Arg::with_name("user id")
                .short("u")
                .long("uid")
                .takes_value(true)
                .required(false),
        )
        .arg(
            Arg::with_name("group id")
                .short("g")
                .long("gid")
                .takes_value(true)
                .required(false)
                .requires("user id"),
        )
        .arg(
            Arg::with_name("chroot")
                .short("c")
                .long("chroot")
                .takes_value(true)
                .required(true)
                .requires("entry point"),
        )
        .arg(
            Arg::with_name("hostname")
                .short("h")
                .long("hostname")
                .takes_value(true)
                .required(false)
                .requires("entry point"),
        )
        //args must the last argument
        .arg(
            Arg::with_name("arguments")
                .short("a")
                .long("args")
                .takes_value(true)
                .multiple(true)
                .required(false)
                .empty_values(true)
                .allow_hyphen_values(true)
                .min_values(0)
                .requires("entry point"),
        )
        .get_matches();
    let uid = matches.value_of("user id").unwrap().parse::<u16>().unwrap();
    let gid = matches
        .value_of("group id")
        .unwrap()
        .parse::<u16>()
        .unwrap();
    let hostname = CString::new(matches.value_of("hostname").unwrap()).unwrap();
    let chroot_path = CString::new(matches.value_of("chroot").unwrap()).unwrap();
    let entry_point = CString::new(matches.value_of("entry point").unwrap()).unwrap();
    let args: Vec<CString> = match matches.values_of("arguments") {
        Some(matches) => {
            let mut args: Vec<CString> = Vec::new();
            //push first argument as the entry point name itself, required for execv
            args.push(CString::new(entry_point.clone()).unwrap());
            for arg in matches {
                args.push(CString::new(arg).unwrap());
            }
            args
        }
        None => Vec::new(),
    };
    let user_map = UserMap::new(uid, gid);
    let command = Cmd::new(entry_point, args);
    NsConfig::new(command, chroot_path, user_map, hostname)
}

fn create_namespace_mapping(UserMap { uid, gid }: UserMap) {
    let pid = "self";
    let setgroups_file = format!("/proc/{}/setgroups", pid);
    let mut setgroups = OpenOptions::new()
        .write(true)
        .read(true)
        .open(&setgroups_file)
        .unwrap();
    setgroups
        .write_all(b"deny\n")
        .expect("Unable to write to setgroups");
    setgroups.flush().unwrap();
    let uid_map_file = format!("/proc/{}/uid_map", pid);
    let mut uid_map = OpenOptions::new()
        .read(true)
        .write(true)
        .open(uid_map_file)
        .unwrap();
    let uid_map_content = format!("0 {} 1\n", uid);
    uid_map
        .write_all(uid_map_content.as_bytes())
        .expect("Unable to write GID map");
    uid_map.flush().unwrap();
    drop(uid_map);
    let gid_map_file = format!("/proc/{}/gid_map", pid);
    let mut gid_map = OpenOptions::new()
        .read(true)
        .write(true)
        .open(gid_map_file)
        .unwrap();
    let gid_map_content = format!("0 {} 1\n", gid);
    gid_map
        .write_all(gid_map_content.as_bytes())
        .expect("Unable to write GID map");
    gid_map.flush().unwrap();
}

fn setup_chroot_env(chroot_path: CString) {
    unsafe {
        //Bind mounts before chroot
        let res = libc::mount(
            CString::new("/mounts/readonly/").unwrap().as_ptr(),
            CString::new("/containerfs/mp").unwrap().as_ptr(),
            std::ptr::null(),
            libc::MS_BIND, //Note readonly flag wont work here
            std::ptr::null(),
        );
        if res != 0 {
            println!(
                "bind mount failed with an error -> {:?}",
                Error::last_os_error()
            );
        } else {
            //remount as readonly as of now, later
            let res = libc::mount(
                std::ptr::null(),
                CString::new("/containerfs/mp").unwrap().as_ptr(),
                std::ptr::null(),
                libc::MS_RDONLY | libc::MS_BIND | libc::MS_REMOUNT,
                std::ptr::null(),
            );
            if res != 0 {
                println!(
                    "bind readonly switch failed with an error -> {:?}",
                    Error::last_os_error()
                );
            }
        }
        let res = libc::chroot(chroot_path.as_ptr());
        if res != 0 {
            println!(
                "chroot failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
        let res = libc::chdir(CString::new("/").unwrap().as_ptr());
        if res != 0 {
            println!("chdir failed with an error -> {:?}", Error::last_os_error());
        }
        //Mount proc filesystem
        let res = libc::mount(
            //CString::new("").unwrap().as_ptr(),
            std::ptr::null(),
            CString::new("/proc").unwrap().as_ptr(),
            CString::new("proc").unwrap().as_ptr(),
            0u64,
            std::ptr::null(),
            //CString::new("").unwrap().as_ptr() as *const libc::c_void,
        );
        if res != 0 {
            println!(
                "proc mount failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
    }
}

fn exec_in_ns(Cmd { path, args }: Cmd) -> libc::c_int {
    unsafe {
        let mut argsp: Vec<*const libc::c_char> = args.iter().map(|arg| arg.as_ptr()).collect();
        argsp.push(std::ptr::null()); //NULL terminated
        let res = libc::execv(path.as_ptr(), argsp.as_ptr());
        if res != 0 {
            println!(
                "Entry point execution failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
        res
    }
}

extern "C" fn setup_ns(ns_config: *mut NsConfig) -> libc::c_int {
    let ns_config: &NsConfig = unsafe { &mut *ns_config };
    //Set hostname
    unsafe {
        let res = libc::sethostname(
            ns_config.hostname.as_ptr(),
            ns_config.hostname.as_bytes().len(),
        );
        if res != 0 {
            println!(
                "proc mount failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
    }
    //Do mappings UID and GID mappings
    create_namespace_mapping(ns_config.user_map());

    //Chroot and Proc Mount
    setup_chroot_env(ns_config.chroot_path());

    //EXECV the entry point replacing the clone completely
    exec_in_ns(ns_config.entry_point())
}

fn main() {
    //CLONE and then EXEC entry point in CLONE
    unsafe {
        let mut ns_config = parse_args();
        let mut nstack = [0u8; 4096];
        let ptr = nstack.as_mut_ptr().offset(nstack.len() as isize);
        let ptr_aligned = ptr.offset((ptr as usize % 16) as isize * -1);
        let pid = libc::clone(
            std::mem::transmute(setup_ns as extern "C" fn(*mut NsConfig) -> libc::c_int),
            ptr_aligned as *mut libc::c_void,
            //CLONE FLAGS
            CLONE_NEWNS
                | CLONE_NEWUTS
                | CLONE_NEWIPC
                | CLONE_NEWUSER
                | CLONE_NEWPID
                | CLONE_NEWNET
                | SIGCHLD,
            &mut ns_config as *mut _ as *mut libc::c_void,
        );
        if pid != 0 {
            println!("Entry point PID -> {}", pid);

            let mut rusage: libc::rusage = std::mem::MaybeUninit::uninit().assume_init();
            let mut status: i32 = 0;
            let options: i32 = 0;

            let res = libc::wait4(pid, &mut status, options, &mut rusage);
            println!("CN WAIT RESULT -> {}", res);
            println!("CN RUSAGE -> {:#?}", rusage);
            println!("CN WAIT STATUS -> {}", status);
            if status != 0 {
                println!(
                    "CN WAIT ERROR WHILE RUNNING -> {:?}",
                    Error::last_os_error()
                );
            }
        } // no else
    }
}
</pre>
Output
<pre>
$ target/debug/container --chroot /containerfs/ --uid 1000 --gid 1000 --entry /bin/bash --hostname my-container --args --login
Entry point PID -> 13724
bash-4.3# exit
</pre>
