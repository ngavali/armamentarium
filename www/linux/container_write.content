<h3><a href="#linux" onclick="_().loadContent(this,'linux','ContentBody');" >Containers</a> - Let's build one</h3></p>
<r>Working on it. Coming soon!!!</r></p>
In case you want to have a look at basics of Namespaces, click <a href="#linux/container_intro" onclick="_().loadContent(this,'linux/container_intro','ContentBody');">introduction</a>.</p>
<center>
<image src="/images/container_flow.svg" width="400px">
Fig(a). execution flow.</p>
</center>
<!--
Example uses hindu mythological names</br>
Brahma the creator of all Lokas (different worlds)</br>
<*>Loka is an analogy for the container.</br>
<*>Brahma is the container spawner</p>-->
Have a linux filesystem structure created under /containerfs directory (accessible via user executing this binary). Which will have all the essential utilities such as bash and other per your need. Copy them from the local system into this directory.</p>
<pre>
/containerfs/
├── bin		#some utilities
│   ├── bash	#required
│   ├── hostname
│   ├── ls
│   ├── ping
│   ├── ps
├── etc
├── file
├── lib
│   └── x86_64-linux-gnu
│       ├── libacl.so.1
│       ├── libattr.so.1
│       ├── libblkid.so.1
│       ├── libcap.so.2
│       ├── libc.so.6
│       ├── libdl.so.2
│       ├── libmount.so.1
│       ├── libnsl.so.1
│       ├── libpcre.so.3
│       ├── libprocps.so.3
│       ├── libselinux.so.1
│       ├── libtinfo.so.5
│       └── libuuid.so.1
├── lib64
│   └── ld-linux-x86-64.so.2
├── mp
├── proc
├── sbin
│   ├── ifconfig
│   └── ip
└── usr
    └── bin
        └── id
</pre>
Short version
<h3>Go</h3>
<pre>
package main

import (
        "fmt"
        "os"
        "os/exec"
        "syscall"
)

func main() {
        switch os.Args[1] {
        case "run":
                run()
        case "loka":
                loka()
        default:
                fmt.Println("Usage: ./brahma run command")
        }
}

func run() {
        fmt.Printf("Creating Loka for %v\n", os.Args[2:])
        cmd := exec.Command("/proc/self/exe", append([]string{"loka"}, os.Args[2:]...)...)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &syscall.SysProcAttr{
                Cloneflags: syscall.CLONE_NEWNS |
                        syscall.CLONE_NEWUTS |
                        syscall.CLONE_NEWIPC |
                        syscall.CLONE_NEWPID |
                        syscall.CLONE_NEWNET |
                        syscall.CLONE_NEWUSER,
                //Map UID
                UidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getuid(), //UID of current program to be mapped with
                                ContainerID: 0,           //UID in container
                                Size:        1,
                        },
                },
                //Map GID
                GidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getgid(), //GID of current program to be mapped with
                                ContainerID: 0,           //GID in container
                                Size:        1,
                        },
                },
        }
        _err := cmd.Start()
        if _err != nil {
                fmt.Println("Error while creating Loka ->", _err)
        } else {
                fmt.Println("Loka created successfully!!!")
        }
        if _err := cmd.Wait(); _err != nil {
                fmt.Println("Error while in Loka ->", _err)
        }
        fmt.Println("Loka distroyed!!!")
}

func loka() {
        fmt.Printf("Preparing %v in new Loka\n", os.Args[2:])
        syscall.Sethostname([]byte("my-loka"))
        syscall.Chroot("/containerfs")               //New root for the Loka container
        syscall.Chdir("/")                           //Change directory
        syscall.Mount("proc", "proc", "proc", 0, "") //Mount new proc
        //Replace the current process. Leaving no trace of the parent /proc/self/exe
        _err := syscall.Exec(os.Args[2], os.Args[3:], nil)
        if _err != nil {
                fmt.Println("Loka error ->", _err)
        }
        fmt.Println("I am dying!!!")
}
</pre>
Long version
<h3>Rust</h3>
I am still working on it!!!</br>
Here you will see exactly what is happening under the hood.
<pre>
extern crate libc;
use libc::{
    CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, CLONE_NEWUSER, CLONE_NEWUTS, SIGCHLD,
};
use rustc_serialize::json;
use std::ffi::CString;
use std::fs::File;
use std::fs::OpenOptions;
use std::io::prelude::*;
use std::io::Error;

#[derive(Debug, Clone)]
struct Cmd {
    path: CString,
    args: Vec<CString>,
}

impl Cmd {
    fn new(path: CString, args: Vec<CString>) -> Cmd {
        Cmd { path, args }
    }
}

#[derive(Debug, Clone)]
struct MountBinds {
    source: CString,
    target: CString,
    read_only: Option<bool>,
}

impl MountBinds {
    fn new(source: String, target: String, read_only: Option<bool>) -> MountBinds {
        MountBinds {
            source: CString::new(source.as_bytes()).unwrap(),
            target: CString::new(target.as_bytes()).unwrap(),
            read_only,
        }
    }
}

#[derive(Debug, Clone)]
struct UserMap {
    uid: u16,
    gid: u16,
}

impl UserMap {
    fn new(uid: u16, gid: u16) -> UserMap {
        UserMap { uid, gid }
    }
}

#[derive(Debug, Clone)]
struct NsConfig {
    hostname: Option<CString>,
    command: Cmd,
    user_map: UserMap,
    bind_map: Vec<MountBinds>,
    chroot_path: CString,
}

impl NsConfig {
    fn from_json_config(ns_json_config: NsConfigJson) -> NsConfig {
        let mut bind_map = Vec::new();
        for bm in ns_json_config.mount_bindings {
            bind_map.push(MountBinds::new(bm.source, bm.target, bm.read_only));
        }
        NsConfig {
            chroot_path: CString::new(ns_json_config.chroot.as_bytes()).unwrap(),
            command: Cmd::new(
                CString::new(ns_json_config.program.executable.as_bytes()).unwrap(),
                Vec::new(),
            ),
            bind_map,
            user_map: UserMap::new(ns_json_config.user_map.uid, ns_json_config.user_map.gid),
            hostname: {
                match ns_json_config.hostname {
                    Some(hostname) => match CString::new(hostname.as_bytes()) {
                        Ok(hostname) => Some(hostname),
                        Err(_err) => panic!(_err),
                    },
                    None => None,
                }
            },
        }
    }

    fn entry_point(&self) -> Cmd {
        self.command.clone()
    }

    fn bind_map(&self) -> Vec<MountBinds> {
        self.bind_map.clone()
    }

    fn user_map(&self) -> UserMap {
        self.user_map.clone()
    }

    fn chroot_path(&self) -> CString {
        self.chroot_path.clone()
    }
}

#[derive(RustcDecodable, RustcEncodable, Debug)]
struct BindMountMaps {
    source: String,
    target: String,
    read_only: Option<bool>,
}

#[derive(RustcDecodable, RustcEncodable, Debug)]
struct Program {
    executable: String,
    args: Vec<String>,
}

#[derive(RustcDecodable, RustcEncodable, Debug)]
struct UserMappings {
    uid: u16,
    gid: u16,
}

#[derive(RustcDecodable, RustcEncodable, Debug)]
struct NsConfigJson {
    chroot: String,
    hostname: Option<String>,
    mount_bindings: Vec<BindMountMaps>,
    program: Program,
    user_map: UserMappings,
}

impl NsConfigJson {
    fn from_file(config_file_name: String) -> NsConfigJson {
        let error_message = format!("Config file not found: {}", config_file_name);
        let mut file = File::open(config_file_name).expect(error_message.as_str());
        let mut server_config = String::new();
        file.read_to_string(&mut server_config).unwrap();
        let ns_config_json: NsConfigJson = json::decode(&mut server_config).unwrap();
        ns_config_json
    }
}

fn create_namespace_mapping(UserMap { uid, gid }: UserMap) {
    let pid = "self";
    let setgroups_file = format!("/proc/{}/setgroups", pid);
    let uid_map_file = format!("/proc/{}/uid_map", pid);
    let gid_map_file = format!("/proc/{}/gid_map", pid);
    let mut setgroups = OpenOptions::new()
        .write(true)
        .read(true)
        .open(&setgroups_file)
        .unwrap();
    setgroups
        .write_all(b"deny\n")
        .expect("Unable to write to setgroups");
    setgroups.flush().unwrap();
    drop(setgroups);
    let mut uid_map = OpenOptions::new()
        .read(true)
        .write(true)
        .open(uid_map_file)
        .unwrap();
    let uid_map_content = format!("0 {} 1\n", uid);
    uid_map
        .write_all(uid_map_content.as_bytes())
        .expect("Unable to write GID map");
    uid_map.flush().unwrap();
    drop(uid_map);
    let mut gid_map = OpenOptions::new()
        .read(true)
        .write(true)
        .open(gid_map_file)
        .unwrap();
    let gid_map_content = format!("0 {} 1\n", gid);
    gid_map
        .write_all(gid_map_content.as_bytes())
        .expect("Unable to write GID map");
    gid_map.flush().unwrap();
    drop(gid_map);
}

fn setup_mount_binds(mount_bind_maps: Vec<MountBinds>) {
    unsafe {
        //Bind mounts before chroot
        for bm in mount_bind_maps {
            let res = libc::mount(
                bm.source.as_ptr(),
                bm.target.as_ptr(),
                std::ptr::null(),
                libc::MS_BIND, //Note readonly flag wont work here
                std::ptr::null(),
            );
            if res != 0 {
                println!(
                    "bind mount failed with an error -> {:?}",
                    Error::last_os_error()
                );
            } else {
                //remount as readonly as of now, later
                println!("mount point {:?}", bm.target);
                let res = libc::mount(
                    std::ptr::null(),
                    bm.target.as_ptr(),
                    std::ptr::null(),
                    libc::MS_RDONLY | libc::MS_BIND | libc::MS_REMOUNT,
                    std::ptr::null(),
                );
                if res != 0 {
                    println!(
                        "bind readonly switch failed with an error -> {:?}",
                        Error::last_os_error()
                    );
                }
            }
        }
    }
}

fn setup_chroot_env(chroot_path: CString) {
    unsafe {
        let res = libc::chroot(chroot_path.as_ptr());
        if res != 0 {
            println!(
                "chroot failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
        let res = libc::chdir(CString::new("/").unwrap().as_ptr());
        if res != 0 {
            println!("chdir failed with an error -> {:?}", Error::last_os_error());
        }
        //Mount proc filesystem
        let res = libc::mount(
            std::ptr::null(),
            CString::new("/proc").unwrap().as_ptr(),
            CString::new("proc").unwrap().as_ptr(),
            0u64,
            std::ptr::null(),
        );
        if res != 0 {
            println!(
                "proc mount failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
    }
}

fn exec_in_ns(Cmd { path, args }: Cmd) -> libc::c_int {
    unsafe {
        let mut argsp: Vec<*const libc::c_char> = args.iter().map(|arg| arg.as_ptr()).collect();
        argsp.push(std::ptr::null()); //NULL terminated
        let res = libc::execv(path.as_ptr(), argsp.as_ptr());
        if res != 0 {
            println!(
                "Entry point execution failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
        res
    }
}

extern "C" fn setup_ns(ns_config: *mut NsConfig) -> libc::c_int {
    let ns_config: &NsConfig = unsafe { &mut *ns_config };
    //Set hostname
    unsafe {
        if let Some(hostname) = ns_config.hostname.clone() {
            let res = libc::sethostname(hostname.as_ptr(), hostname.as_bytes().len());
            if res != 0 {
                println!(
                    "proc mount failed with an error -> {:?}",
                    Error::last_os_error()
                );
            }
        }
        //Do mappings UID and GID mappings
        create_namespace_mapping(ns_config.user_map());

        //Mount bindings
        setup_mount_binds(ns_config.bind_map());
        //Chroot and Proc Mount
        setup_chroot_env(ns_config.chroot_path());

        //EXECV the entry point replacing the clone completely
        exec_in_ns(ns_config.entry_point())
    }
}

fn main() {
    //CLONE and then EXEC entry point in CLONE
    unsafe {
        //let mut ns_config = parse_args();
        let json_config = NsConfigJson::from_file("container.json".to_string());
        let mut ns_config = NsConfig::from_json_config(json_config);
        let mut nstack = [0u8; 4096];
        let ptr = nstack.as_mut_ptr().offset(nstack.len() as isize);
        let ptr_aligned = ptr.offset((ptr as usize % 16) as isize * -1);
        let pid = libc::clone(
            std::mem::transmute(setup_ns as extern "C" fn(*mut NsConfig) -> libc::c_int),
            ptr_aligned as *mut libc::c_void,
            //CLONE FLAGS
            CLONE_NEWNS
                | CLONE_NEWUTS
                | CLONE_NEWIPC
                | CLONE_NEWUSER
                | CLONE_NEWPID
                | CLONE_NEWNET
                | SIGCHLD,
            &mut ns_config as *mut _ as *mut libc::c_void,
        );
        if pid != 0 {
            println!("Entry point PID -> {}", pid);

            let mut rusage: libc::rusage = std::mem::MaybeUninit::uninit().assume_init();
            let mut status: i32 = 0;
            let options: i32 = 0;

            let res = libc::wait4(pid, &mut status, options, &mut rusage);
            println!("CN WAIT RESULT -> {}", res);
            println!("CN RUSAGE -> {:#?}", rusage);
            println!("CN WAIT STATUS -> {}", status);
            if status != 0 {
                println!(
                    "CN WAIT ERROR WHILE RUNNING -> {:?}",
                    Error::last_os_error()
                );
            }
        } // no else
    }
}
</pre>
container.json
<pre>
{
    "chroot": "/containerfs",
    "hostname": "my-container",
    "mount_bindings": [
        {
            "read_only": true,
            "source": "/mounts/readonly/",
            "target": "/containerfs/mp"
        }
    ],
    "program": {
        "args": [
            "-c",
            "/bin/sleep 20s"
        ],
        "executable": "/bin/bash"
    },
    "user_map": {
        "gid": 1000,
        "uid": 1000
    }
}
</pre>
Output
<pre>
$ cargo run
Entry point PID -> 13724
bash-4.3# exit
</pre>
