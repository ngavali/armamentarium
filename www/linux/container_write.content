<h3><a href="#linux" onclick="_().loadContent(this,'linux','ContentBody');" >Containers</a> - Let's build one</h3></p>
<r>Working on it. Coming soon!!!</r></p>
In case you want to have a look at namespaces basic click <a href="#linux/container_intro" onclick="_().loadContent(this,'linux/container_intro','ContentBody');">introduction</a>.</p>
Example uses hindu mythological names</br>
Brahma the creator of all Lokas (different worlds)</br>
<*>Loka is an analogy for the container.</br>
<*>Brahma is the container spawner</p>
Have a linux filesystem structure created under /containerfs directory (accessible via user executing this binary). Which will have all the essential utilities such as bash and other per your need.

<h3>Go</h3>
<pre>
package main

import (
        "fmt"
        "os"
        "os/exec"
        "syscall"
)

func main() {
        switch os.Args[1] {
        case "run":
                run()
        case "loka":
                loka()
        default:
                fmt.Println("Usage: ./brahma run command")
        }
}

func run() {
        fmt.Printf("Creating Loka for %v\n", os.Args[2:])
        cmd := exec.Command("/proc/self/exe", append([]string{"loka"}, os.Args[2:]...)...)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &syscall.SysProcAttr{
                Cloneflags: syscall.CLONE_NEWNS |
                        syscall.CLONE_NEWUTS |
                        syscall.CLONE_NEWIPC |
                        syscall.CLONE_NEWPID |
                        syscall.CLONE_NEWNET |
                        syscall.CLONE_NEWUSER,
                //Map UID
                UidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getuid(), //UID of current program to be mapped with
                                ContainerID: 0,           //UID in container
                                Size:        1,
                        },
                },
                //Map GID
                GidMappings: []syscall.SysProcIDMap{
                        {
                                HostID:      os.Getgid(), //GID of current program to be mapped with
                                ContainerID: 0,           //GID in container
                                Size:        1,
                        },
                },
        }
        _err := cmd.Start()
        if _err != nil {
                fmt.Println("Error while creating Loka ->", _err)
        } else {
                fmt.Println("Loka created successfully!!!")
        }
        if _err := cmd.Wait(); _err != nil {
                fmt.Println("Error while in Loka ->", _err)
        }
        fmt.Println("Loka distroyed!!!")
}

func loka() {
        fmt.Printf("Preparing %v in new Loka\n", os.Args[2:])
        syscall.Sethostname([]byte("my-loka"))
        syscall.Chroot("/containerfs")               //New root for the Loka container
        syscall.Chdir("/")                           //Change directory
        syscall.Mount("proc", "proc", "proc", 0, "") //Mount new proc
        //Replace the current process. Leaving no trace of the parent /proc/self/exe
        _err := syscall.Exec(os.Args[2], os.Args[3:], nil)
        if _err != nil {
                fmt.Println("Loka error ->", _err)
        }
        fmt.Println("I am dying!!!")
}
</pre>
<h3>Rust</h3>
I am still working on it!!!</br>
Here you will see exactly what is happening under the hood.
<pre>
extern crate clap;
extern crate libc;
use clap::{App, Arg};
use libc::{
    CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, CLONE_NEWUSER, CLONE_NEWUTS, SIGCHLD,
};
use std::ffi::CString;
use std::fs::OpenOptions;
use std::io::prelude::*;
use std::io::Error;

#[derive(Debug)]
struct Cmd {
    path: CString,
    chroot_path: CString,
    map_uid: u16,
    map_gid: u16,
    args: Vec<CString>,
}

impl Cmd {
    fn new(
        path: CString,
        chroot_path: CString,
        map_uid: u16,
        map_gid: u16,
        args: Vec<CString>,
    ) -> Cmd {
        Cmd {
            path,

            chroot_path,
            map_uid,
            map_gid,
            args,
        }
    }
}

fn parse_args() -> (bool, bool, CString, Vec<CString>, CString) {
    let matches = App::new("brahma")
        .version("1.0")
        .author("Nilesh Gavali")
        .arg(
            Arg::with_name("run")
                .short("r")
                .long("run")
                .takes_value(false),
        )
        .arg(
            Arg::with_name("namespace")
                .short("n")
                .long("namespace")
                .takes_value(false),
        )
        .arg(
            Arg::with_name("entry point")
                .short("e")
                .long("entry")
                .takes_value(true)
                .required(true),
        )
        .arg(
            Arg::with_name("chroot")
                .short("c")
                .long("chroot")
                .takes_value(true)
                .required(true),
        )
        .arg(
            Arg::with_name("arguments")
                .short("a")
                .long("args")
                .takes_value(true)
                .multiple(true)
                .required(false)
                .empty_values(true)
                .allow_hyphen_values(true)
                .min_values(0),
        )
        .get_matches();
    let is_run_command = matches.is_present("run");
    let is_ns_command = matches.is_present("namespace");
    let chroot_path = CString::new(matches.value_of("chroot").unwrap()).unwrap();
    let entry_point = CString::new(matches.value_of("entry point").unwrap()).unwrap();
    let args: Vec<CString> = match matches.values_of("arguments") {
        Some(matches) => {
            let mut args: Vec<CString> = Vec::new();
            //push first argument as the entry point name itself, required for execv
            args.push(CString::new(entry_point.clone()).unwrap());
            for arg in matches {
                args.push(CString::new(arg).unwrap());
            }
            args
        }
        None => Vec::new(),
    };
    (
        is_run_command,
        is_ns_command,
        entry_point,
        args,
        chroot_path,
    )
}

fn create_namespace_mapping(uid: u16, gid: u16) {
    let pid = "self";
    let setgroups_file = format!("/proc/{}/setgroups", pid);
    let mut setgroups = OpenOptions::new()
        .write(true)
        .read(true)
        .open(&setgroups_file)
        .unwrap();
    setgroups
        .write_all(b"deny\n")
        .expect("Unable to write to setgroups");
    setgroups.flush().unwrap();
    let uid_map_file = format!("/proc/{}/uid_map", pid);
    let mut uid_map = OpenOptions::new()
        .read(true)
        .write(true)
        .open(uid_map_file)
        .unwrap();
    let uid_map_content = format!("0 {} 1\n", uid);
    uid_map
        .write_all(uid_map_content.as_bytes())
        .expect("Unable to write GID map");
    uid_map.flush().unwrap();
    drop(uid_map);
    let gid_map_file = format!("/proc/{}/gid_map", pid);
    let mut gid_map = OpenOptions::new()
        .read(true)
        .write(true)
        .open(gid_map_file)
        .unwrap();
    let gid_map_content = format!("0 {} 1\n", gid);
    gid_map
        .write_all(gid_map_content.as_bytes())
        .expect("Unable to write GID map");
    gid_map.flush().unwrap();
}

fn setup_chroot_env(chroot_path: CString) {
    unsafe {
        let res = libc::chroot(chroot_path.as_ptr());
        if res != 0 {
            println!(
                "chroot failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
        let res = libc::chdir(CString::new("/").unwrap().as_ptr());
        if res != 0 {
            println!("chdir failed with an error -> {:?}", Error::last_os_error());
        }
        //Mount proc filesystem
        let res = libc::mount(
            CString::new("").unwrap().as_ptr(),
            CString::new("/proc").unwrap().as_ptr(),
            CString::new("proc").unwrap().as_ptr(),
            0u64,
            CString::new("").unwrap().as_ptr() as *const libc::c_void,
        );
        if res != 0 {
            println!(
                "proc mount failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
    }
}

fn exec_in_ns(command: &Cmd) -> libc::c_int {
    unsafe {
        let exec = &command.path;
        let mut args: Vec<*const libc::c_char> =
            command.args.iter().map(|arg| arg.as_ptr()).collect();
        args.push(std::ptr::null()); //NULL terminated
        let res = libc::execv(exec.as_ptr(), args.as_ptr());
        if res != 0 {
            println!(
                "Entry point execution failed with an error -> {:?}",
                Error::last_os_error()
            );
        }
        res
    }
}

extern "C" fn setup_ns(command: *mut Cmd) -> libc::c_int {
    let command: &Cmd = unsafe { &mut *command };
    //Do mappings UID and GID mappings
    create_namespace_mapping(command.map_uid, command.map_gid);

    //Chroot and Proc Mount
    setup_chroot_env(command.chroot_path.clone());

    //EXECV the entry point replacing the clone completely
    exec_in_ns(command)
}

fn main() {
    match parse_args() {
        (true, _, command, args, chroot_path) => {
            //CLONE and then EXEC entry point in CLONE
            unsafe {
                //To do: Move UID and GID to arguments
                let mut command = Cmd::new(command, chroot_path, 1000, 1000, args);
                let mut nstack = [0u8; 4096];
                let ptr = nstack.as_mut_ptr().offset(nstack.len() as isize);
                let ptr_aligned = ptr.offset((ptr as usize % 16) as isize * -1);
                let pid = libc::clone(
                    std::mem::transmute(setup_ns as extern "C" fn(*mut Cmd) -> libc::c_int),
                    ptr_aligned as *mut libc::c_void,
                    //CLONE FLAGS
                    CLONE_NEWNS
                        | CLONE_NEWUTS
                        | CLONE_NEWIPC
                        | CLONE_NEWUSER
                        | CLONE_NEWPID
                        | CLONE_NEWNET
                        | SIGCHLD,
                    &mut command as *mut _ as *mut libc::c_void,
                );
                if pid != 0 {
                    println!("Entry point PID -> {}", pid);

                    let mut rusage: libc::rusage = std::mem::MaybeUninit::uninit().assume_init();
                    let mut status: i32 = 0;
                    let options: i32 = 0;

                    let res = libc::wait4(pid, &mut status, options, &mut rusage);
                    println!("CN WAIT RESULT -> {}", res);
                    println!("CN RUSAGE -> {:#?}", rusage);
                    println!("CN WAIT STATUS -> {}", status);
                    if status != 0 {
                        println!(
                            "CN WAIT ERROR WHILE RUNNING -> {:?}",
                            Error::last_os_error()
                        );
                    }
                } else {
                    println!("DONE WITH CLONE");
                }
            }
        }
        (..) => println!("Don't know what to do!!! Please check usage."),
    }
}
</pre>
